{"version":3,"sources":["webpack:///../src/docs/auth-and-authorize.mdx"],"names":["_frontmatter","Object","isExtensible","prototype","hasOwnProperty","call","defineProperty","configurable","value","name","filename","layoutProps","MDXLayout","DefaultLayout","MDXContent","_ref","components","props","_objectWithoutProperties","_excluded","mdx","_extends","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---src-docs-auth-and-authorize-mdx-617b236b308236fe4aa0.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport DefaultLayout from \"C:/Users/Sonish Maharjan/Desktop/texpress/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"authentication-and-authorization\"\n    }}>{`Authentication and Authorization`}</h1>\n    <p>{`Texpress comes with built-in authentication and authorization features. For authentication, you may use the `}<inlineCode parentName=\"p\">{`ProtectedRoute`}</inlineCode>{` for CMS or the `}<inlineCode parentName=\"p\">{`APIProtectedRoute`}</inlineCode>{` decorator for APIs for creating protected routes.`}</p>\n    <h2 {...{\n      \"id\": \"protected-routes\"\n    }}>{`Protected Routes`}</h2>\n    <p>{`The CMS's `}<inlineCode parentName=\"p\">{`ProtectedRoute`}</inlineCode>{` decorator uses the Passport's `}<inlineCode parentName=\"p\">{`Local Strategy`}</inlineCode>{` by storing sessions on redis to authenticate the users. You may swap this part with your own authentication logic as required. To swap this, you can change the logic of the `}<inlineCode parentName=\"p\">{`auth`}</inlineCode>{` shared middleware being used by the `}<inlineCode parentName=\"p\">{`ProtectedRoute`}</inlineCode>{` decorator.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { Controller, ProtectedRoute } from 'core/controllers';\n\n@Controller('/my-resource')\nexport class MyResourceController {\n    @ProtectedRoute({\n        // Registers a protected route in CMS\n        path: '/',\n        method: HTTPMethods.Get,\n    })\n    @CatchAsync\n    async getMyProtectedResouces(req: Request, res: Response) {\n        // handle GET\n    }\n}\n`}</code></pre>\n    <p>{`Above example registers a protected route `}<inlineCode parentName=\"p\">{`GET /my-resource`}</inlineCode>{` which throws an `}<inlineCode parentName=\"p\">{`Unauthorized Exception`}</inlineCode>{` if the user is not logged in.`}<br parentName=\"p\"></br>{`\n`}{`Similar to this, the `}<inlineCode parentName=\"p\">{`APIProtectedRoute`}</inlineCode>{` uses Passport's `}<inlineCode parentName=\"p\">{`JWT Strategy`}</inlineCode>{` to authenticate the user. Again, if you need, you may swap this part with your own authentication logic as required. To swap this, you can change the logic of the `}<inlineCode parentName=\"p\">{`jwtAuth`}</inlineCode>{` shared middleware being used by the `}<inlineCode parentName=\"p\">{`APIProtectedRoute`}</inlineCode>{` decorator.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { ApiController, APIProtectedRoute } from 'core/controllers';\n\n@ApiController('/my-resource')\nexport class ApiResourceController {\n    @APIProtectedRoute({\n        // Registers a protected route for API\n        path: '/',\n        method: HTTPMethods.Get,\n    })\n    async getMyProtectedResouces(req: Request, res: Response) {\n        // handle GET\n    }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"authorization\"\n    }}>{`Authorization`}</h2>\n    <p>{`The authorization features helps you manage permissions in the `}<inlineCode parentName=\"p\">{`CMS`}</inlineCode>{` application. The authorization features uses the `}<inlineCode parentName=\"p\">{`users`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`roles`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`permissions`}</inlineCode>{` entities to handle the permissions. Authorization can be done in two ways, action based or route based.`}</p>\n    <h3 {...{\n      \"id\": \"users-roles-and-permissions\"\n    }}>{`Users, Roles, and Permissions`}</h3>\n    <p>{`Permissions in the CMS are synced to the database from the `}<inlineCode parentName=\"p\">{`cms.config.ts`}</inlineCode>{` file in the `}<inlineCode parentName=\"p\">{`texpress-cms/src/configs`}</inlineCode>{` application directory. The permissions from this file are synced to the database when you first run the seeders when setting up `}<inlineCode parentName=\"p\">{`texpress`}</inlineCode>{`. Along with the permissions, a user with the role of `}<inlineCode parentName=\"p\">{`'super-admin'`}</inlineCode>{` is also created. The `}<inlineCode parentName=\"p\">{`'super-admin'`}</inlineCode>{` role always has all the permissions allowed by default. Next time you add new modules, and their permissions to the CMS config file, you can resync these permissions with the database by clicking on the `}<inlineCode parentName=\"p\">{`Sync Permissions`}</inlineCode>{` button in the CMS application's Permissions page.`}</p>\n    <h3 {...{\n      \"id\": \"action-based-authorization\"\n    }}>{`Action Based Authorization`}</h3>\n    <p>{`The action based authorization simply works by checking if the specified action is in the allowed permissions list of the currently authenticated user. These actions are checked against the `}<inlineCode parentName=\"p\">{`action`}</inlineCode>{` values stored in the `}<inlineCode parentName=\"p\">{`permissions`}</inlineCode>{` table. To use this, add the `}<inlineCode parentName=\"p\">{`canAccess`}</inlineCode>{` middleware whilst registering routes.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { canAccess } from 'shared/middlewares';\n\n@Controller('/my-resource')\nexport class ApiResourceController {\n    @ProtectedRoute({\n        path: '/',\n        method: HTTPMethods.Get,\n        middlewares: [canAccess('my-resource.view')], // check if 'my-resource.view' permission is allowed the user\n    })\n    async getMyProtectedResouces(req: Request, res: Response) {\n        // handle GET\n    }\n}\n`}</code></pre>\n    <p>{`Above example checks if the logged in user is allowed to perform the action `}<inlineCode parentName=\"p\">{`'my-resource.view'`}</inlineCode>{`. If not, a `}<inlineCode parentName=\"p\">{`Forbidden Exception`}</inlineCode>{` will be thrown.`}</p>\n    <h3 {...{\n      \"id\": \"route-based-authorization\"\n    }}>{`Route Based Authorization`}</h3>\n    <p>{`The route based authorization checks if the users permission list is allowed to access both the `}<inlineCode parentName=\"p\">{`route`}</inlineCode>{` as well as the `}<inlineCode parentName=\"p\">{`HTTP method`}</inlineCode>{`. To add route based authorization, add the `}<inlineCode parentName=\"p\">{`@CanAccess`}</inlineCode>{` decorator to the controller class.`}<br parentName=\"p\"></br>{`\n`}<strong parentName=\"p\">{`Note: For now, using `}<inlineCode parentName=\"strong\">{`@CanAccess`}</inlineCode>{` decorator will authorize all the routes registered in the controller.`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { Controller, ProtectedRoute, CanAccess } from 'core/controllers';\n\n@Controller('/my-resource')\n@CanAccess\nexport class ApiResourceController {\n    @ProtectedRoute({\n        path: '/',\n        method: HTTPMethods.Get,\n    })\n    async getMyProtectedResouces(req: Request, res: Response) {\n        // handle GET\n    }\n\n    @ProtectedRoute({\n        path: '/',\n        method: HTTPMethods.Post,\n    })\n    async createMyProtectedResouces(req: Request, res: Response) {\n        // handle POST\n    }\n}\n`}</code></pre>\n    <p>{`In above example, since the `}<inlineCode parentName=\"p\">{`@CanAccess`}</inlineCode>{` decorator has been used, accessing any of the routes `}<inlineCode parentName=\"p\">{`GET /my-resource`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`POST /my-resource`}</inlineCode>{`, the permissions will be checked against the permissions list of the logged in user. For example, when a logged in user tries to access `}<inlineCode parentName=\"p\">{`GET /my-resource`}</inlineCode>{`, a check will be made if the user has permission to perform `}<inlineCode parentName=\"p\">{`GET`}</inlineCode>{` method on the route `}<inlineCode parentName=\"p\">{`/my-resource`}</inlineCode>{`. If not, a `}<inlineCode parentName=\"p\">{`Forbidden Exception`}</inlineCode>{` will be thrown.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}
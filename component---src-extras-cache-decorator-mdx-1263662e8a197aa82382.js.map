{"version":3,"sources":["webpack:///../src/extras/cache-decorator.mdx"],"names":["_frontmatter","Object","isExtensible","prototype","hasOwnProperty","call","defineProperty","configurable","value","name","filename","layoutProps","MDXLayout","DefaultLayout","MDXContent","_ref","components","props","_objectWithoutProperties","_excluded","mdx","_extends","mdxType","parentName","isMDXComponent"],"mappings":"yRAMaA,EAAe,QAAG,IAAAA,UAAAC,OAAAD,IAAAC,OAAAC,aAAAF,KAAAC,OAAAE,UAAAC,eAAAC,KAAAL,EAAA,eAAAC,OAAAK,eAAAN,EAAA,cAAAO,cAAA,EAAAC,MAAA,CAAAC,KAAA,eAAAC,SAAA,oCAC/B,MAAMC,EAAc,CAClBX,gBAEIY,EAAYC,IACH,SAASC,EAAUC,GAG/B,IAHgC,WACjCC,GAEDD,EADIE,EAAKC,YAAAH,EAAAI,GAER,OAAOC,YAACR,EAASS,YAAA,GAAKV,EAAiBM,EAAK,CAAED,WAAYA,EAAYM,QAAQ,cAG5EF,YAAA,MACE,GAAM,2BAAyB,2BAEjCA,YAAA,qCAAgCA,YAAA,cAAYG,WAAW,KAAG,UAAwB,yDAA0DH,YAAA,cAAYG,WAAW,KAAG,gBAA8B,0DAA2DH,YAAA,cAAYG,WAAW,KAAG,UAAwB,2MAA4MH,YAAA,MAAIG,WAAW,MAAS,YAC/gBH,YAAA,cAAYG,WAAW,KAAG,SAAuB,6EACvDH,YAAA,kBACEA,YAAA,KAAGG,WAAW,cAAY,iBAAmBH,YAAA,cAAYG,WAAW,KAAG,SAAuB,yFAEhGH,YAAA,MACE,GAAM,6BAA2B,6BAEnCA,YAAA,gBAAWA,YAAA,cAAYG,WAAW,KAAG,SAAuB,+BAC5DH,YAAA,UACEA,YAAA,MAAIG,WAAW,MAAI,wCACnBH,YAAA,MAAIG,WAAW,MAAI,iEAErBH,YAAA,WAAKA,YAAA,QAAMG,WAAW,MAClB,UAAa,uBAAqB,+MAQtCH,YAAA,+CAA0CA,YAAA,cAAYG,WAAW,KAAG,iCAA+C,+KACnHH,YAAA,MACE,GAAM,iCAA+B,iCAEvCA,YAAA,gOAA2NA,YAAA,MAAIG,WAAW,MAAS,KACrPH,YAAA,UAAQG,WAAW,KAAG,8GACpBH,YAAA,MACE,GAAM,WAAS,WAEjBA,YAAA,mGACAA,YAAA,WAAKA,YAAA,QAAMG,WAAW,MAClB,UAAa,uBAAqB,wVAWtCH,YAAA,0CAAqCA,YAAA,cAAYG,WAAW,KAAG,eAA6B,gBAAiBH,YAAA,cAAYG,WAAW,KAAG,MAAoB,uBAAwBH,YAAA,cAAYG,WAAW,KAAG,MAAoB,8CAA+CH,YAAA,UAAQG,WAAW,KAAIH,YAAA,cAAYG,WAAW,UAAQ,cAAoC,sCAAuCH,YAAA,cAAYG,WAAW,KAAG,eAA6B,yBAA0BH,YAAA,cAAYG,WAAW,KAAG,MAAoB,KAAMH,YAAA,cAAYG,WAAW,KAAG,MAAoB,wCACpkBH,YAAA,MACE,GAAM,4DAA0D,qBACzCA,YAAA,cAAYG,WAAW,MAAI,QAAsB,eAAgBH,YAAA,UAAQG,WAAW,MAAKH,YAAA,cAAYG,WAAW,UAAQ,kCACjJH,YAAA,sFAAiFA,YAAA,cAAYG,WAAW,KAAG,iBAA+B,kEAAmEH,YAAA,cAAYG,WAAW,KAAG,iBAA+B,sIACtQH,YAAA,WAAKA,YAAA,QAAMG,WAAW,MAClB,UAAa,uBAAqB,0aAczC,IAAAT,UAAAb,OAAAa,IAAAb,OAAAC,aAAAY,KAAAb,OAAAE,UAAAC,eAAAC,KAAAS,EAAA,eAAAb,OAAAK,eAAAQ,EAAA,cAAAP,cAAA,EAAAC,MAAA,CAAAC,KAAA,aAAAC,SAAA,oCAEDI,EAAWU,gBAAiB","file":"component---src-extras-cache-decorator-mdx-1263662e8a197aa82382.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport DefaultLayout from \"C:/Users/Sonish Maharjan/Desktop/texpress/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"caching-with-decorators\"\n    }}>{`Caching with Decorators`}</h1>\n    <p>{`Texpress also provides a `}<inlineCode parentName=\"p\">{`@Cache`}</inlineCode>{` decorator for caching results of a method. While the `}<inlineCode parentName=\"p\">{`CacheService`}</inlineCode>{` provides a more general-purpose caching solution, the `}<inlineCode parentName=\"p\">{`@Cache`}</inlineCode>{` decorator is specifically designed for caching the results of method calls. It abstracts away the caching logic and makes it easier to cache the results of a method call with just a simple decorator.`}<br parentName=\"p\"></br>{`\n`}{`The `}<inlineCode parentName=\"p\">{`Cache`}</inlineCode>{` decorator takes two arguments: the key and an optional TTL (in seconds).`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Note that the `}<inlineCode parentName=\"p\">{`Cache`}</inlineCode>{` decorator can only be used if the method returns the value that needs to be cached.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"using-the-cache-decorator\"\n    }}>{`Using the Cache Decorator`}</h2>\n    <p>{`The `}<inlineCode parentName=\"p\">{`Cache`}</inlineCode>{` decorator does two things:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Caches the result of the method call`}</li>\n      <li parentName=\"ul\">{`Returns the cached result for every subsequent method calls.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`class SomeService {\n    @Cache('my_heavy_data') // Caches the returned value of fetchSomeHeavyProcessedData.\n    async fetchSomeHeavyProcessedData() {\n        return this.getMyHeavyDat();\n    }\n}\n`}</code></pre>\n    <p>{`Above example caches the result of `}<inlineCode parentName=\"p\">{`fetchSomeHeavyProcessedData()`}</inlineCode>{` method call when the method is called for the very first time. For every subsequent method calls, the cached result will be returned until the cached data is not expired.`}</p>\n    <h2 {...{\n      \"id\": \"generating-dynamic-cache-keys\"\n    }}>{`Generating Dynamic Cache Keys`}</h2>\n    <p>{`In some cases, you might need to cache the result on dynamically generated keys. Keys can be generated dynamically using the arguments passed to the method, and applying your key generation logic with those data.`}<br parentName=\"p\"></br>{`\n`}<strong parentName=\"p\">{`To do this, pass a callback method as the first argument that takes the same argument list as the method.`}</strong></p>\n    <h3 {...{\n      \"id\": \"example\"\n    }}>{`Example`}</h3>\n    <p>{`Consider a scenario where you need to cache the data of users based on their user ids.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`class AuthService {\n    @Cache<AuthService, 'getUserById'>(\n        (id) => \\`user:\\${id}\\`, // the key generation callback method with same argumet as the method itself\n        600 // optional TTL in secods\n    )\n    getUserById(id: number) {\n        return user; // fetch the user with matching ID from database and return\n    }\n}\n`}</code></pre>\n    <p>{`In above example, calling the `}<inlineCode parentName=\"p\">{`getUserById`}</inlineCode>{` method with `}<inlineCode parentName=\"p\">{`id`}</inlineCode>{` argument passed as `}<inlineCode parentName=\"p\">{`28`}</inlineCode>{`, the results will be cached under the key `}<strong parentName=\"p\"><inlineCode parentName=\"strong\">{`'user:28'`}</inlineCode></strong>{`. For every subsequent call to the `}<inlineCode parentName=\"p\">{`getUserById`}</inlineCode>{` method with the same `}<inlineCode parentName=\"p\">{`id`}</inlineCode>{` (`}<inlineCode parentName=\"p\">{`28`}</inlineCode>{`), the cached data will be returned.`}</p>\n    <h3 {...{\n      \"id\": \"understanding-the-type-arguments-authservice-getuserbyid\"\n    }}>{`Understanding the `}<inlineCode parentName=\"h3\">{`Type`}</inlineCode>{` arguments: `}<strong parentName=\"h3\"><inlineCode parentName=\"strong\">{`<AuthService, 'getUserById'>`}</inlineCode></strong></h3>\n    <p>{`In above example, two type arguments are also passed, the current service `}<inlineCode parentName=\"p\">{`'AuthService'`}</inlineCode>{`, and the name of the method the decorator is being applied to `}<inlineCode parentName=\"p\">{`'getUserById'`}</inlineCode>{`. They are needed to take advantage of the type support of TypeScript when passing the key generation logic as the first argument.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`class AuthService {\n    @Cache<AuthService, 'getUserById'>(\n        (id) => \\`user:\\${id}\\`, // here \\`id\\` is automatically type annotated as \\`number\\` since the id is of\n        // type \\`number\\` in the method the decorator is applied to i.e. \\`getUserById'\n        600\n    )\n    getUserById(\n        id: number // the id's type data is used to enforce the type of id as \\`number\\` in above decorator.\n    ) {}\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}
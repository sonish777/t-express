{"version":3,"sources":["webpack:///../src/docs/swagger-doc.mdx"],"names":["_frontmatter","Object","isExtensible","prototype","hasOwnProperty","call","defineProperty","configurable","value","name","filename","layoutProps","MDXLayout","DefaultLayout","MDXContent","_ref","components","props","_objectWithoutProperties","_excluded","mdx","_extends","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---src-docs-swagger-doc-mdx-7a48a8b39701f87d21a3.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport DefaultLayout from \"C:/Users/Sonish Maharjan/Desktop/texpress/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"swagger-documentation\"\n    }}>{`Swagger Documentation`}</h1>\n    <p>{`Texpress comes with built-in provider and decorators to help you genereate OpenAPI specification swagger documentation for your APIs. To add swagger documentation, use the `}<inlineCode parentName=\"p\">{`SwaggerDocProvider`}</inlineCode>{` when starting up the API server.`}</p>\n    <h2 {...{\n      \"id\": \"setting-up-swagger-documentation\"\n    }}>{`Setting up Swagger Documentation`}</h2>\n    <p>{`Pass the `}<inlineCode parentName=\"p\">{`SwaggerDocProvider`}</inlineCode>{` provider imported from `}<inlineCode parentName=\"p\">{`core`}</inlineCode>{` package to your providers list during the API server startup. Proivde the middleware by passing the necessary options from `}<inlineCode parentName=\"p\">{`SwaggerDocProviderProps`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { SwaggerDocProvider, SwaggerDocProviderProps } from 'core/swagger';\nimport * as controllers from '@api/controllers';\n\nexport function bootstrap() {\n    const server = new Server(controllers);\n    return server.startup(Number(ServerConfig.PORT), {\n        name: 'API Server',\n        middlewareProviders: [\n            // other providers\n            provideMiddleware<SwaggerDocProviderProps>(SwaggerDocProvider, {\n                title: 'Texpress API Documentation',\n                apiPaths: [__dirname + '/controllers/**/*.ts'],\n                servers: [{ url: \\`\\${ServerConfig.URL}/api/v1\\` }],\n                authSchemes: ['BearerAuth'],\n                controllers,\n            }),\n        ],\n    });\n}\n`}</code></pre>\n    <p>{`The `}<inlineCode parentName=\"p\">{`SwaggerDocProviderProps`}</inlineCode>{` takes the following properties:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`title (required): The title of your API documentation.`}</li>\n      <li parentName=\"ul\">{`version (optional): The version of your API.`}</li>\n      <li parentName=\"ul\">{`apiPaths (required): An array of paths to your API controllers. This is used by Swagger to generate documentation for your API.`}</li>\n      <li parentName=\"ul\">{`servers (required): An array of server objects. Each object should contain a url property, which represents the base URL of your API.`}</li>\n      <li parentName=\"ul\">{`authSchemes (optional): An array of authentication schemes used by your API. Swagger supports several authentication schemes, such as BasicAuth and BearerAuth.`}</li>\n      <li parentName=\"ul\">{`apiKeyConfig (optional): An object that specifies the configuration for an API key. This is used for API key authentication.`}</li>\n      <li parentName=\"ul\">{`controllers (optional): An object that contains the controllers used by your API.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"defining-routes-and-methods\"\n    }}>{`Defining Routes and Methods`}</h2>\n    <p>{`Routes and Methods are automatically defined when using the `}<inlineCode parentName=\"p\">{`ApiController`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Route`}</inlineCode>{` decorators.`}</p>\n    <h2 {...{\n      \"id\": \"grouping-operations\"\n    }}>{`Grouping Operations`}</h2>\n    <p>{`You can group APIs by using the `}<inlineCode parentName=\"p\">{`@ApiTag`}</inlineCode>{` decorator which takes the name of the group as the first argument.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`@ApiController('/users')\n@ApiTag('Users') // All APIs under this controller are grouped into \\`Users\\`\nexport class ApiUserController extends APIBaseController {}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"defining-metadatas\"\n    }}>{`Defining Metadatas`}</h2>\n    <p>{`You can use the `}<inlineCode parentName=\"p\">{`@ApiMetadata`}</inlineCode>{` decorator to define metadatas for the APIs. It takes an `}<inlineCode parentName=\"p\">{`ApiMetadataProps`}</inlineCode>{` option argument which takes the following properties.`}</p>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`description: a string that provides a brief description of the API method. This description can be used to help users understand what the method does.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`summary: a string that provides a summary of the API method. This summary can be used to provide a concise description of the method.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`consumes: an array of strings that specifies the media types that are consumed by the API method. This property can be used to provide information about the request body of the API method.`}</p>\n      </li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { ApiMetadata } from 'core/swagger';\n\n@ApiController('/users')\n@ApiTag('Users')\nexport class ApiUserController extends APIBaseController {\n    @Route({ method: HTTPMethods.Get, path: '/' })\n    @ApiMetadata({\n        description: 'Get all the users list',\n        summary: 'Returns users',\n        consumes: ['application/json'],\n    })\n    @CatchAsync\n    async findAll(req: Request, res: Response) {\n        // fetch and return users\n    }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"defining-api-parameters\"\n    }}>{`Defining API Parameters`}</h2>\n    <p>{`You can use the `}<inlineCode parentName=\"p\">{`@ApiParameter`}</inlineCode>{` decorator to define API parameters i.e. path parameters or query parameters. It takes an `}<inlineCode parentName=\"p\">{`ApiParametersProps`}</inlineCode>{` option paramter which takes the following properties.`}</p>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`in: a string that specifies the location of the parameter. It can have one of two values: 'path' or 'query'. If the value is 'path', the parameter is extracted from the URL path. If the value is 'query', the parameter is extracted from the query string.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`schema: an array of object that specifies the schema of the parameter. The schema object has a name and type property.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`description: an optional string that provides a brief description of the parameter.`}</p>\n      </li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { ApiMetadata } from 'core/swagger';\n\n@ApiController('/users')\n@ApiTag('Users')\nexport class ApiUserController extends APIBaseController {\n    @Route({ method: HTTPMethods.Get, path: '/' })\n    @ApiParameter({\n        in: 'query',\n        schema: [\n            {\n                name: 'keywords',\n                type: 'string',\n                required: false,\n            },\n            {\n                name: 'page',\n                type: 'number',\n                required: false,\n            },\n            {\n                name: 'limit',\n                type: 'number',\n                required: false,\n            },\n        ],\n    })\n    @CatchAsync\n    async findAll(req: Request, res: Response) {\n        // fetch and return users\n    }\n}\n`}</code></pre>\n    <p>{`In above example, the `}<inlineCode parentName=\"p\">{`/users`}</inlineCode>{` API takes 3 optional query parameters, `}<inlineCode parentName=\"p\">{`keywords`}</inlineCode>{` of type string and `}<inlineCode parentName=\"p\">{`page`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`limit`}</inlineCode>{` of type numbers which are usually used for generating paginated responses.`}</p>\n    <h2 {...{\n      \"id\": \"defining-schemas\"\n    }}>{`Defining Schemas`}</h2>\n    <p>{`Instead of passing each of the schema properties in an `}<inlineCode parentName=\"p\">{`@ApiParameter`}</inlineCode>{` decorator directly, a better way is to defines these schemas separately using the `}<inlineCode parentName=\"p\">{`@Schema`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`@SchemaProperty`}</inlineCode>{` decorators. Then use this `}<inlineCode parentName=\"p\">{`schema`}</inlineCode>{` on the ApiParameter decorator.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { Schema, SchemaProperty } from 'core/swagger';\n\n@Schema()\nexport class CommonSearchQueryDto implements CommonSearchQuery {\n    @SchemaProperty({\n        type: 'string',\n    })\n    keywords?: string;\n\n    @SchemaProperty({\n        type: 'number',\n        example: '1',\n    })\n    page?: number;\n\n    @SchemaProperty({\n        type: 'number',\n        example: '25',\n    })\n    take?: number;\n}\n`}</code></pre>\n    <p>{`After defining the schema, simply import and pass the schema when defining the parameters with `}<inlineCode parentName=\"p\">{`ApiParameter`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { ApiMetadata } from 'core/swagger';\n\n@ApiController('/users')\n@ApiTag('Users')\nexport class ApiUserController extends APIBaseController {\n    @Route({ method: HTTPMethods.Get, path: '/' })\n    @ApiParameter({ in: 'query', schema: CommonSearchQueryDto }) //import and use the Schema defined above\n    @CatchAsync\n    async findAll(req: Request, res: Response) {\n        // fetch and return users\n    }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"defining-api-body\"\n    }}>{`Defining API Body`}</h2>\n    <p>{`You can use the `}<inlineCode parentName=\"p\">{`@ApiBody`}</inlineCode>{` decorator to define body of the request. It takes an `}<inlineCode parentName=\"p\">{`ApiBodyProps`}</inlineCode>{` option paramter which takes the following properties.`}</p>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`contentType: a string that specifies the MIME type of the request body. The supported values are 'application/json' and 'multipart/form-data'. The default value is 'application/json'.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`schema: a schema class decorated with the `}<inlineCode parentName=\"p\">{`@Schema`}</inlineCode>{` decorator as described above.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`required: an optional boolean property that specifies whether the request body is required or not.`}</p>\n      </li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`@Schema()\nexport class CreateUserDto {\n    @SchemaProperty({\n        type: 'string',\n    })\n    email: string;\n\n    @SchemaProperty({\n        type: 'string',\n    })\n    password: string;\n}\n`}</code></pre>\n    <p>{`Then, we can define the API body as follows:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { ApiBody } from 'core/swagger';\n\n@ApiController('/users')\n@ApiTag('Users')\nexport class ApiUserController extends APIBaseController {\n    @APIProtectedRoute({\n        method: HTTPMethods.Post,\n        path: '/',\n    })\n    @ApiBody({\n        schema: CreateUserDto,\n    })\n    async create(req: TypedBody<CreateUserDto>, res: Response) {\n        // create user\n    }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"defining-api-responses\"\n    }}>{`Defining API Responses`}</h2>\n    <p>{`You can use the `}<inlineCode parentName=\"p\">{`@ApiResponse`}</inlineCode>{` decorator to define the response of an API. It takes an `}<inlineCode parentName=\"p\">{`ApiResponseProps`}</inlineCode>{` option paramter which takes the following properties.`}</p>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`code: This property is an optional string that specifies the HTTP status code of the response. If not specified, the default value is '200'.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`description: This property is an optional string that describes the response.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`contentType: This property is an optional string that specifies the MIME type of the response body. The supported values are 'application/json', 'text/plain', 'application/pdf', etc. The default value is 'application/json'.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`schema: This property takes the `}<inlineCode parentName=\"p\">{`@Schema`}</inlineCode>{` decorated classes that represent the body of the response. If you donot have a separate schema class, you may also define the schema properties using the OpenAPI's specification`}</p>\n      </li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { ApiResponse } from 'core/swagger';\n\n@Schema()\nexport class Tokens {\n    @SchemaProperty({ type: 'string' })\n    accessToken: string;\n\n    @SchemaProperty({ type: 'string' })\n    refreshToken: string;\n}\n\n@ApiController('/users')\n@ApiTag('Users')\nexport class ApiUserController extends APIBaseController {\n    @Route({ method: HTTPMethods.Post, path: '/login' })\n    @ApiBody({ schema: LoginDto })\n    @ApiResponse({ schema: Tokens })\n    async login(req: Request) {\n        // user login\n    }\n}\n`}</code></pre>\n    <p>{`Or without a schema class, using OpenAPI 3's specifications,`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { ApiResponse } from 'core/swagger';\n\n@ApiController('/users')\n@ApiTag('Users')\nexport class ApiUserController extends APIBaseController {\n    @Route({ method: HTTPMethods.Post, path: '/login' })\n    @ApiBody({ schema: LoginDto })\n    @ApiResponse({\n        code: '200',\n        contentType: 'application/json',\n        schema: {\n            type: 'object',\n            properties: {\n                accessToken: {\n                    type: 'string',\n                    description: 'Access Token of logged in user',\n                },\n                refreshToken: {\n                    type: 'string',\n                    description:\n                        'Refresh Token for refreshing expired access token',\n                },\n            },\n        },\n    })\n    async login(req: Request) {\n        // user login\n    }\n}\n`}</code></pre>\n    <p>{`For more details on the schema properties, please refer to the OpenAPI Specification of Swagger.`}</p>\n    <h2 {...{\n      \"id\": \"authentication\"\n    }}>{`Authentication`}</h2>\n    <p>{`You can add `}<inlineCode parentName=\"p\">{`BearerAuth`}</inlineCode>{` and/or `}<inlineCode parentName=\"p\">{`ApiKeyAuth`}</inlineCode>{` authentication schemes using Texpress. To add auth schemes, first register the schemes when registering the `}<inlineCode parentName=\"p\">{`SwaggerDocProvider`}</inlineCode>{`. This is shown in the first section `}<inlineCode parentName=\"p\">{`Setting up Swagger Documentation`}</inlineCode>{`. Then you can use the `}<inlineCode parentName=\"p\">{`@ApiBearerAuth`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`@ApiKeyAuth`}</inlineCode>{` to add authentication to the routes.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { ApiBody, ApiBearerAuth } from 'core/swagger';\n\n@ApiController('/users')\n@ApiTag('Users')\nexport class ApiUserController extends APIBaseController {\n    @APIProtectedRoute({ method: HTTPMethods.Post, path: '/' })\n    @ApiBearerAuth() // pass bearer auth token to the request\n    @ApiBody({ schema: CreateUserDto })\n    async create(req: Request, res: Response) {\n        // create user\n    }\n}\n`}</code></pre>\n    <p>{`Similarly, you can use `}<inlineCode parentName=\"p\">{`@ApiKeyAuth`}</inlineCode>{` decorator to add API key authentication to the routes. With ApiKeyAuth, you can also use the decorator at controller class level if you need to add api key authentication to all the routes within the controller. To do so, pass the first argument of root as `}<inlineCode parentName=\"p\">{`true`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { ApiBody, ApiKeyAuth } from 'core/swagger';\n\n@ApiController('/users')\n@ApiKeyAuth(true) // Adds API key authentication to all the routes\n@ApiTag('Users')\nexport class ApiUserController extends APIBaseController {\n    // register routes\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}
(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{NQOB:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return l})),n.d(t,"default",(function(){return b}));var a=n("IKa1"),i=n("Yh9w"),r=(n("r0ML"),n("V0Ug")),o=n("sN0p");n("xH0s");const s=["components"],l={};void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!Object.prototype.hasOwnProperty.call(l,"__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/extras/rate-limiter-decorator.mdx"}});const c={_frontmatter:l},p=o.a;function b(e){let{components:t}=e,n=Object(i.a)(e,s);return Object(r.b)(p,Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"rate-limiting-with-decorators"},"Rate Limiting with Decorators"),Object(r.b)("p",null,"Texpress also provides a ",Object(r.b)("inlineCode",{parentName:"p"},"@Throttle")," decorator for rate limiting. The ",Object(r.b)("inlineCode",{parentName:"p"},"@Throttle")," decorator provides a convenient way to apply rate limiting to specific methods or endpoints in an application, without having to manually call the RateLimiterService every time. Using the RateLimiterService directly may be more suitable in situations where more granular control over the rate limiting configuration is required. In most cases, the ",Object(r.b)("inlineCode",{parentName:"p"},"Throttle")," decorator should be sufficient."),Object(r.b)("h2",{id:"using-the-rate-limiting-decorator"},"Using the Rate Limiting Decorator"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"@Throttle")," decorator takes two arguments, the key to used for throtting the request as the first argument and an optional ",Object(r.b)("inlineCode",{parentName:"p"},"RateLimiterOptions")," argument. The ",Object(r.b)("inlineCode",{parentName:"p"},"RateLimiterOptions")," is an object that has 3 optional properties, attempts, windowDuration, and blockDuration. These values are the same as the ones used by the ",Object(r.b)("inlineCode",{parentName:"p"},"RateLimiterService"),".",Object(r.b)("br",{parentName:"p"}),"\n","These arguments, if not provided, will fallback to the default values set in the configuration JSON file."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-typescript"},"class AuthService {\n    @Throttle('login', {\n        attempts: 5,\n        windowDuration: 10,\n        blockDuration: 10,\n    })\n    async login(username: string, password: string) {\n        // Log in the user with the provided credentials\n    }\n}\n")),Object(r.b)("p",null,"In above example, if the login method is called more than ",Object(r.b)("inlineCode",{parentName:"p"},"5 times")," within the duration of ",Object(r.b)("inlineCode",{parentName:"p"},"10 seconds"),", the request will be blocked for ",Object(r.b)("inlineCode",{parentName:"p"},"10 seconds")," for any login attempts."),Object(r.b)("h2",{id:"generating-dynamic-rate-limiting-keys"},"Generating Dynamic Rate Limiting Keys"),Object(r.b)("p",null,"In some cases, you might need to limit the request rate based on dynamically generated keys. Keys can be generated dynamically using the arguments passed to the method, and applying your key generation logic with those data.",Object(r.b)("br",{parentName:"p"}),"\n",Object(r.b)("strong",{parentName:"p"},"To do this, pass a callback method as the first argument that takes the same argument list as the method.")),Object(r.b)("h3",{id:"example"},"Example"),Object(r.b)("p",null,"Consider a scenario where you need to rate limit the login route based on the request IP Address."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-typescript"},"@Controller('/auth')\nclass AuthController {\n    @Route({ path: '/login', method: HTTPMethods.Post })\n    @Throttle<AuthController, 'login'>((req) => `login_ip:${req.ip}`, {\n        attempts: 2,\n        blockDuration: 20,\n    })\n    async login(req: Request) {\n        // Log in the user based on provided credentials\n    }\n}\n")),Object(r.b)("p",null,"In above example, the ",Object(r.b)("inlineCode",{parentName:"p"},"login")," route when accessed is rate limited based on the requested IP Address. The ",Object(r.b)("inlineCode",{parentName:"p"},"@Throttle")," decorator takes an key generation callback method as the first argument, that takes the same argument list as the method it is being applied to i.e. ",Object(r.b)("inlineCode",{parentName:"p"},"login"),". Therefore, both the callback key generation method, and the login method takes ",Object(r.b)("inlineCode",{parentName:"p"},"req")," as the first argument which is of type ",Object(r.b)("inlineCode",{parentName:"p"},"Express.Request"),".",Object(r.b)("br",{parentName:"p"}),"\n","If the requesting IP Address is 127.12.09.01 then the rate limiting key for this request will be ",Object(r.b)("inlineCode",{parentName:"p"},"'login_ip:127.12.09.01'"),"."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"Type")," argument in ",Object(r.b)("inlineCode",{parentName:"p"},"@Throttle")," decorator are passed the same way as they are passed in ",Object(r.b)("inlineCode",{parentName:"p"},"@Cache")," decorator. Please refer to ",Object(r.b)("a",{parentName:"p",href:"./cache-decorator#understanding-the-type-arguments-authservice-getuserbyid"},Object(r.b)("inlineCode",{parentName:"a"},"Cache")," Decorator")," if you want to understand how these type arguments are passed."))}void 0!==b&&b&&b===Object(b)&&Object.isExtensible(b)&&!Object.prototype.hasOwnProperty.call(b,"__filemeta")&&Object.defineProperty(b,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/extras/rate-limiter-decorator.mdx"}}),b.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-extras-rate-limiter-decorator-mdx-9479cc26f44ab159dbbe.js.map
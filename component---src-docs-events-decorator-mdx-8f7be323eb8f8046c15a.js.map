{"version":3,"sources":["webpack:///../src/docs/events-decorator.mdx","webpack:///../src/images/code_1.jpg"],"names":["_frontmatter","Object","isExtensible","prototype","hasOwnProperty","call","defineProperty","configurable","value","name","filename","layoutProps","MDXLayout","DefaultLayout","MDXContent","_ref","components","props","_objectWithoutProperties","_excluded","mdx","_extends","mdxType","parentName","src","require","style","isMDXComponent","module","exports"],"mappings":"2RAMaA,EAAe,QAAG,IAAAA,UAAAC,OAAAD,IAAAC,OAAAC,aAAAF,KAAAC,OAAAE,UAAAC,eAAAC,KAAAL,EAAA,eAAAC,OAAAK,eAAAN,EAAA,cAAAO,cAAA,EAAAC,MAAA,CAAAC,KAAA,eAAAC,SAAA,mCAC/B,MAAMC,EAAc,CAClBX,gBAEIY,EAAYC,IACH,SAASC,EAAUC,GAG/B,IAHgC,WACjCC,GAEDD,EADIE,EAAKC,YAAAH,EAAAI,GAER,OAAOC,YAACR,EAASS,YAAA,GAAKV,EAAiBM,EAAK,CAAED,WAAYA,EAAYM,QAAQ,cAG5EF,YAAA,MACE,GAAM,oCAAkC,oCAE1CA,YAAA,6QAAwQA,YAAA,MAAIG,WAAW,MAAS,iWAEhSH,YAAA,MACE,GAAM,yBAAuB,yBAE/BA,YAAA,+CAA0CA,YAAA,cAAYG,WAAW,KAAG,gCAA8C,8GAA+GH,YAAA,MAAIG,WAAW,MAAS,KAC3PH,YAAA,UAAQG,WAAW,KAAG,6LACpBH,YAAA,MACE,GAAM,0CAAwC,0CAEhDA,YAAA,oEACAA,YAAA,UACEA,YAAA,MAAIG,WAAW,MAAKH,YAAA,cAAYG,WAAW,MAAI,eAA6B,0BAC5EH,YAAA,MAAIG,WAAW,MAAKH,YAAA,cAAYG,WAAW,MAAI,qBAAmC,yCAClFH,YAAA,MAAIG,WAAW,MAAKH,YAAA,cAAYG,WAAW,MAAI,mBAAiC,uIAElFH,YAAA,WAAKA,YAAA,QAAMG,WAAW,MAClB,UAAa,uBAAqB,oPAQtCH,YAAA,sIACAA,YAAA,UACEA,YAAA,MAAIG,WAAW,MACbH,YAAA,KAAGG,WAAW,MAAI,mCAAqCH,YAAA,cAAYG,WAAW,KAAG,qBAAmC,sCAAuCH,YAAA,cAAYG,WAAW,KAAG,aAA2B,yBAA0BH,YAAA,cAAYG,WAAW,KAAG,mBAAiC,wCAAyCH,YAAA,cAAYG,WAAW,KAAG,SAAuB,YAAaH,YAAA,cAAYG,WAAW,KAAG,aAA2B,uCAAwCH,YAAA,cAAYG,WAAW,KAAG,mBAAiC,eACpiBH,YAAA,cAAYG,WAAW,MACrBH,YAAA,KAAGG,WAAW,cAAaH,YAAA,cAAYG,WAAW,KAAG,mBAAiC,cAAeH,YAAA,cAAYG,WAAW,KAAG,cAA4B,wBAAyBH,YAAA,cAAYG,WAAW,KAAG,UAAwB,oCAG1OH,YAAA,MAAIG,WAAW,MACbH,YAAA,KAAGG,WAAW,MAAI,yEAA2EH,YAAA,cAAYG,WAAW,KAAG,iBAA+B,0CAA2CH,YAAA,cAAYG,WAAW,KAAG,MAAoB,QAASH,YAAA,cAAYG,WAAW,KAAG,0GAAwH,+BAC1YH,YAAA,cAAYG,WAAW,MACrBH,YAAA,KAAGG,WAAW,cAAaH,YAAA,UAAQG,WAAW,KAAG,YAAcH,YAAA,cAAYG,WAAW,UAAQ,SAAuB,sIAGzHH,YAAA,MAAIG,WAAW,MACbH,YAAA,KAAGG,WAAW,MAAI,OAASH,YAAA,cAAYG,WAAW,KAAG,qBAAmC,gDAAiDH,YAAA,cAAYG,WAAW,KAAG,gCAA8C,yCAA0CH,YAAA,cAAYG,WAAW,KAAG,cAA4B,wBAGrTH,YAAA,MACE,GAAM,mCAAiC,mCAEzCA,YAAA,kEACAA,YAAA,mEACAA,YAAA,WAAKA,YAAA,QAAMG,WAAW,MAClB,UAAa,uBAAqB,iJAMtCH,YAAA,uCACAA,YAAA,WAAKA,YAAA,QAAMG,WAAW,MAClB,UAAa,uBAAqB,64BA2BtCH,YAAA,oCACAA,YAAA,OAAKI,IAAKC,EAAQ,QAAyBC,MAAO,CAChD,MAAS,SAEXN,YAAA,MACE,GAAM,8BAA4B,8BAEpCA,YAAA,wGAAmGA,YAAA,cAAYG,WAAW,KAAG,SAAuB,uPAAwPH,YAAA,cAAYG,WAAW,KAAG,SAAuB,0BAA2BH,YAAA,cAAYG,WAAW,KAAG,SAAuB,+BACzgBH,YAAA,WAAKA,YAAA,QAAMG,WAAW,MAClB,UAAa,uBAAqB,+gBAuBtCH,YAAA,gHAA2GA,YAAA,cAAYG,WAAW,KAAG,4BAA0C,YAAaH,YAAA,cAAYG,WAAW,KAAG,aAA2B,oBAAqBH,YAAA,cAAYG,WAAW,KAAG,QAAsB,WAGzT,IAAAT,UAAAb,OAAAa,IAAAb,OAAAC,aAAAY,KAAAb,OAAAE,UAAAC,eAAAC,KAAAS,EAAA,eAAAb,OAAAK,eAAAQ,EAAA,cAAAP,cAAA,EAAAC,MAAA,CAAAC,KAAA,aAAAC,SAAA,mCAEDI,EAAWa,gBAAiB,G,uBC9I5BC,EAAOC,QAAU,IAA0B","file":"component---src-docs-events-decorator-mdx-8f7be323eb8f8046c15a.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport DefaultLayout from \"C:/Users/Sonish Maharjan/Desktop/texpress/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"emitting-events-using-decorators\"\n    }}>{`Emitting Events using Decorators`}</h1>\n    <p>{`Instead of manually injecting the event class and emitting events, you can create special event emitter decorators that does just that for you. You can create your own event emitter decorator using a factory method that creates the emitter behind the scene.`}<br parentName=\"p\"></br>{`\n`}{`This makes it much easier to emit events as you don't have to manually create an instance of the event emitter, define the event, and emit it with the correct payload. It also helps keep your code organized and easy to understand, as you can clearly see which methods emit which events, and how the returned values are mapped to event payloads.`}</p>\n    <h2 {...{\n      \"id\": \"event-emitter-factory\"\n    }}>{`Event Emitter Factory`}</h2>\n    <p>{`Texpress provides a factory method `}<inlineCode parentName=\"p\">{`EventEmitterDecoratorFactory`}</inlineCode>{`. Using this utility method, you can create method decorators that emit events from the current event type.`}<br parentName=\"p\"></br>{`\n`}<strong parentName=\"p\">{`NOTE: There is one thing to keep in mind when emitting events using decorators. The payload needed to emit/consume the event must be returned by the method the decorator is applied to.`}</strong></p>\n    <h3 {...{\n      \"id\": \"using-the-eventemitterdecoratorfactory\"\n    }}>{`Using the EventEmitterDecoratorFactory`}</h3>\n    <p>{`The EventEmitterDecoratorFactory takes three arguments,`}</p>\n    <ul>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`Event class`}</inlineCode>{` as the first argument`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`Name of the event`}</inlineCode>{` to be emitted as the second argument`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`Mapper function`}</inlineCode>{` as the third argument that maps the return value of the applied decorator's method to the payload required to emit the decorator.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`\nexport const AuthEventsEmitter = <EventName extends keyof AuthEventsTypes>(\n    event: EventName,\n    mapper: (returnedValue: any) => AuthEventsTypes[EventName] | false\n) => EventEmitterDecoratorFactory(AuthEvents, event, mapper);\n\n`}</code></pre>\n    <p>{`The above example may look weird if you haven't worked with TypeScript decoratos as much. But let's try to break it down,`}</p>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`First we create a method called `}<inlineCode parentName=\"p\">{`AuthEventsEmitter`}</inlineCode>{`. This method takes a generic type `}<inlineCode parentName=\"p\">{`EventName`}</inlineCode>{` constrained to keyof `}<inlineCode parentName=\"p\">{`AuthEventsTypes`}</inlineCode>{`. This means that the first arugment `}<inlineCode parentName=\"p\">{`event`}</inlineCode>{` of type `}<inlineCode parentName=\"p\">{`EventName`}</inlineCode>{` can only be one of the keys in the `}<inlineCode parentName=\"p\">{`AuthEventsTypes`}</inlineCode>{` interface.`}</p>\n        <blockquote parentName=\"li\">\n          <p parentName=\"blockquote\"><inlineCode parentName=\"p\">{`AuthEventsTypes`}</inlineCode>{` is one of `}<inlineCode parentName=\"p\">{`EventTypes`}</inlineCode>{` as explained in the `}<inlineCode parentName=\"p\">{`Events`}</inlineCode>{` section of the documentation.`}</p>\n        </blockquote>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`The second argument mapper is a function that takes a single argument `}<inlineCode parentName=\"p\">{`returnedValue`}</inlineCode>{` and returns either an array of payload`}<inlineCode parentName=\"p\">{`or`}</inlineCode>{`false`}<inlineCode parentName=\"p\">{`. The return type of the mapper function is constrained to the type of the corresponding event in the `}</inlineCode>{`AuthEventsTypes\\` interface.`}</p>\n        <blockquote parentName=\"li\">\n          <p parentName=\"blockquote\"><strong parentName=\"p\">{`Note the `}<inlineCode parentName=\"strong\">{`false`}</inlineCode>{` value for mapper. This is used for conditionally emitting events. Look at the end of this page for Conditional Event Emitting.`}</strong></p>\n        </blockquote>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`The `}<inlineCode parentName=\"p\">{`AuthEventsEmitter`}</inlineCode>{` method then forwards these arguments to the `}<inlineCode parentName=\"p\">{`EventEmitterDecoratorFactory`}</inlineCode>{` followed by the Event class which is `}<inlineCode parentName=\"p\">{`AuthEvents`}</inlineCode>{` in above example.`}</p>\n      </li>\n    </ul>\n    <h2 {...{\n      \"id\": \"emitting-events-using-decorator\"\n    }}>{`Emitting Events using Decorator`}</h2>\n    <p>{`Now let's take an look into how to the above emitter.`}</p>\n    <p>{`Consider the AuthEvents has the following event types:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`interface AuthEventTypes {\n    'send-welcome-email': [{ user: UserEntity, emailCode: string }];\n    // ...other event types as needed\n}\n`}</code></pre>\n    <p>{`Now let's emit this event.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`\nclass AuthService() {\n\n    @AuthEventsEmitter(\n        // First argument, the name of the event from AuthEventTypes, 'send-welcome-email'\n        'send-welcome-email',\n        // Second argument, A mapper function that takes the returned value of the method createUserAndSendEmail() as argument\n        // and returns a payload matching the payload type for the event, 'send-welcome-email'\n        (returnedValue: { user: UserEntity, emailCode: string }) =>\n            [\n                { user: returnedValue.user, emailCode: returnedValue.emailCode }\n            ]\n    )\n    async createUserAndSendEmail() {\n        // logic to create user\n\n        // MUST return the payload needed to emit the event.\n        // In this case, an object having user payload and the email code.\n        return {\n            user: user,\n            emailCode: 'WELCOME_EMAIL'\n        }\n    }\n}\n\n`}</code></pre>\n    <p>{`A visual representation`}</p>\n    <img src={require('../images/code_1.jpg')} style={{\n      \"width\": \"70%\"\n    }} />\n    <h2 {...{\n      \"id\": \"conditional-event-emitting\"\n    }}>{`Conditional Event Emitting`}</h2>\n    <p>{`There can be situations where you only need to emit the event based on some conditions. The `}<inlineCode parentName=\"p\">{`false`}</inlineCode>{` value on mapper that you might have seen in above examples when creating the event emitter decorator does exactly this. The mapper function either maps the returned value of the method to the payload required for emitting the event or maps to `}<inlineCode parentName=\"p\">{`false`}</inlineCode>{` value. When mapped to `}<inlineCode parentName=\"p\">{`false`}</inlineCode>{`, the event is not emitted.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`\nclass AuthService() {\n\n    @AuthEventsEmitter(\n        'send-welcome-email',\n        (returnedValue: { user: UserEntity, emailCode: string }) =>\n            returnedValue.user.sendEmail === true ?\n            [\n                { user: returnedValue.user, emailCode: returnedValue.emailCode }\n            ] :\n            false\n    )\n    async createUserAndSendEmail() {\n        // logic to create user\n        return {\n            user: user,\n            emailCode: 'WELCOME_EMAIL'\n        }\n    }\n}\n\n`}</code></pre>\n    <p>{`In above example, the event is only emitted if the user payload in the returned value of the method `}<inlineCode parentName=\"p\">{`createUserAndSendEmail()`}</inlineCode>{` has the `}<inlineCode parentName=\"p\">{`sendEmail`}</inlineCode>{` property set to `}<inlineCode parentName=\"p\">{`true`}</inlineCode>{`.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      ","module.exports = __webpack_public_path__ + \"static/code_1-7e73c9e03774b021ff894122efb625dd.jpg\";"],"sourceRoot":""}